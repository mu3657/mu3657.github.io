[{"title":"Demo","url":"/2025/04/14/Demo/","content":"比赛名称：[TapTap聚光灯挑战]举办时间：[2024.10.8 - 2024.10.29]比赛主题：[Light]  \n游戏概述《光影桥途》是一款类纪念碑谷的3D解谜游戏，玩家需要操控场景中的平行光源，利用投射的影子作为桥梁和互动元素，帮助角色从起点抵达终点。我们的游戏灵感来源于”光”这一主题，探索了光与影的互动关系以及它们如何改变我们对环境的感知。\n游戏特色\n光影互动机制：玩家可以通过调整平行光源的方向，改变特定物体投射的影子形状和位置\n影子即实体：游戏中的影子不仅是视觉效果，更是带有碰撞体的实体，可以作为角色行走的道路或与其他物体的互动媒介\n纪念碑谷式视角：采用3D正交视角，提供清晰的空间感知同时保持美学风格\n\n技术实现使用了以下技术和工具：\n\n游戏引擎：Unity\n编程语言：C#\n设计模式: 单例模式、订阅者模式等\n使用插件    ：DOTween, Shader Graph, Cinemachine等\n\n在开发过程中，最大的技术挑战是实现影子作为实体的物理碰撞系统。我们通过自定义的ShadowVolumeGenerator类解决了这一难题，该类能够：\n\n实时计算投影点：根据光源位置和物体顶点，计算出投影到地面上的点\n凸包算法处理：使用凸包算法确保生成的阴影形状合理且有效\n3D网格生成：将阴影投影点转换为带有高度的3D网格，包括底面、侧面和顶面\n碰撞体添加：为生成的阴影网格添加MeshCollider，使其成为可交互的游戏元素\n\n游戏截图\n\n\n\n实机视频比赛时用的宣传片\n\n  \n  Your browser does not support the video tag.\n\n\n一点小插曲其实灵感最初来源于这样一个笑话\n有两个人决定逃跑，因此他们爬到了屋子的房顶，他们看到了一片片的房顶，隔着一条窄窄的沟，延伸到城里，延伸到自由。第一个人直接跳了过去，毫无压力，但他的朋友不行，他太害怕摔下去！因此，第一个人想了个办法，他说：“嘿，我有个手电筒，我用它照射到房子间的沟，这样你就能踩着光走到我身边了，但是第二个人说：“你在开玩笑吗，当我走到一半的时候你就会把手电筒关掉！\n核心机制具体实现：ShadowVolumeGenerator1. 初始化public class ShadowVolumeGenerator : MonoBehaviour&#123;    public Light lightSource; // 光源    public float entityHeight = 1f; // 阴影实体的高度    public int maxShadowPoints = 1000; // 阴影点的最大数量限制    public List&lt;GameObject&gt; shadowCastingObjects; // 需要生成阴影的物体    public Plane groundPlane;    private List&lt;Vector3&gt; shadowPoints = new List&lt;Vector3&gt;(); // 存储阴影的投影点    private GameObject shadowEntity; // 存储阴影实体    public Material shadowMaterial; // 阴影材质    public GameObject groundPlaneObject;        void Start()    &#123;        // 创建阴影实体        shadowEntity = new GameObject(&quot;SingleShadowEntity&quot;);        shadowEntity.AddComponent&lt;MeshFilter&gt;();        MeshRenderer meshRenderer = shadowEntity.AddComponent&lt;MeshRenderer&gt;();        meshRenderer.material = shadowMaterial;    &#125;\n\n系统初始化时，会创建一个空的GameObject作为阴影实体的容器，并添加必要的渲染组件。这个容器将在后续用于存放生成的阴影网格。\n2. 实时阴影计算在每一帧，系统会根据光源位置、投射物体和地面平面，计算实时阴影：\nvoid Update()&#123;    if (groundPlaneObject == null) return;    // 获取平面的法线和位置    Vector3 planeNormal = groundPlaneObject.transform.up;    Vector3 planePoint = groundPlaneObject.transform.position;    // 定义一个平面    Plane groundPlane = new Plane(planeNormal, planePoint);    // 更新阴影    GenerateShadowUsingProjection(shadowCastingObjects, groundPlane);&#125;\n\n3. 阴影投影点计算阴影生成的第一步是计算物体在光照下投射到地面上的投影点：\nvoid GenerateShadowUsingProjection(List&lt;GameObject&gt; shadowCastingObjects, Plane groundPlane)&#123;    shadowPoints.Clear(); // 清空阴影点列表    foreach (var obj in shadowCastingObjects)    &#123;        MeshFilter meshFilter = obj.GetComponent&lt;MeshFilter&gt;();        if (meshFilter == null) continue;        Mesh mesh = meshFilter.mesh;        Vector3[] vertices = mesh.vertices;        for (int i = 0; i &lt; vertices.Length; i++)        &#123;            Vector3 worldVertex = obj.transform.TransformPoint(vertices[i]);                        Vector3 directionToLight = (worldVertex - lightSource.transform.position).normalized;            // 处理不同光源类型的阴影            if (lightSource.type == LightType.Directional)            &#123;                directionToLight = -lightSource.transform.forward;            &#125;            else if (lightSource.type == LightType.Point)            &#123;                directionToLight = -(worldVertex - lightSource.transform.position).normalized;            &#125;                        // 计算投影点到平面的投影            float distanceToPlane = groundPlane.GetDistanceToPoint(worldVertex);            Vector3 projectedPoint = worldVertex - directionToLight *                 (distanceToPlane / Vector3.Dot(directionToLight, groundPlane.normal));                       shadowPoints.Add(projectedPoint);                        // 达到最大投影点数量限制后跳出循环            if (shadowPoints.Count &gt;= maxShadowPoints)                break;        &#125;    &#125;    // 使用凸包算法处理投影点    shadowPoints = ConvexHull(shadowPoints);        // 如果有足够的点，生成阴影实体    if (shadowPoints.Count &gt; 2)    &#123;        GenerateShadowEntityWithHeight(shadowPoints, groundPlane.normal);    &#125;&#125;\n获取物体顶点：遍历每个需要投影的物体的所有顶点\n计算光照方向：根据光源类型（方向光、点光源）确定投影方向\n平面投影计算：使用平面方程计算顶点在任意平面上的投影点\n投影点收集：收集所有的投影点用于后续处理\n4. 凸包算法处理为了生成合理的阴影形状，这里使用了Graham扫描算法计算投影点的凸包：\nList&lt;Vector3&gt; ConvexHull(List&lt;Vector3&gt; points)&#123;    // 排序点，基于x和z坐标    points.Sort((a, b) =&gt;    &#123;        if (a.x == b.x) return a.z.CompareTo(b.z);        return a.x.CompareTo(b.x);    &#125;);    List&lt;Vector3&gt; hull = new List&lt;Vector3&gt;();    // 凸包的下部分    foreach (var p in points)    &#123;        while (hull.Count &gt;= 2 &amp;&amp; Cross(hull[hull.Count - 2], hull[hull.Count - 1], p) &lt;= 0)        &#123;            hull.RemoveAt(hull.Count - 1);        &#125;        hull.Add(p);    &#125;    // 凸包的上部分    int t = hull.Count + 1;    for (int i = points.Count - 2; i &gt;= 0; i--)    &#123;        var p = points[i];        while (hull.Count &gt;= t &amp;&amp; Cross(hull[hull.Count - 2], hull[hull.Count - 1], p) &lt;= 0)        &#123;            hull.RemoveAt(hull.Count - 1);        &#125;        hull.Add(p);    &#125;    hull.RemoveAt(hull.Count - 1);  // 移除重复的起点    return hull;&#125;// 计算叉积，判断三点形成的转向float Cross(Vector3 o, Vector3 a, Vector3 b)&#123;    return (a.x - o.x) * (b.z - o.z) - (a.z - o.z) * (b.x - o.x);&#125;\n\n5. 阴影实体网格生成最后，系统将投影点转换为完整的3D网格，包括底面、侧面和顶面：\nvoid GenerateShadowEntityWithHeight(List&lt;Vector3&gt; shadowPoints, Vector3 planeNormal)&#123;    MeshFilter meshFilter = shadowEntity.GetComponent&lt;MeshFilter&gt;();    Mesh shadowMesh = new Mesh();    meshFilter.mesh = shadowMesh;    List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();    vertices.AddRange(shadowPoints); // 地面上的阴影投影点        // 添加顶部顶点    foreach (Vector3 point in shadowPoints)    &#123;        vertices.Add(point + planeNormal * entityHeight); // 在法线方向上拔高    &#125;    // 生成底面的三角形    List&lt;int&gt; triangles = new List&lt;int&gt;();    for (int i = 1; i &lt; shadowPoints.Count - 1; i++)    &#123;        triangles.Add(0);       // 第一个顶点        triangles.Add(i);       // 当前顶点        triangles.Add(i + 1);   // 下一个顶点    &#125;    // 生成侧面的三角形    int topStartIndex = shadowPoints.Count;  // 拔高顶点的起始索引    for (int i = 0; i &lt; shadowPoints.Count; i++)    &#123;        int nextIndex = (i + 1) % shadowPoints.Count;        // 连接底部和顶部的顶点，生成侧面        triangles.Add(i);                 // 底面顶点        triangles.Add(nextIndex);         // 下一个底面顶点        triangles.Add(topStartIndex + i); // 对应的顶部顶点        triangles.Add(topStartIndex + i);         // 顶部顶点        triangles.Add(nextIndex);                 // 下一个底面顶点        triangles.Add(topStartIndex + nextIndex); // 对应的顶部顶点    &#125;    // 生成顶面的三角形    for (int i = 1; i &lt; shadowPoints.Count - 1; i++)    &#123;        triangles.Add(topStartIndex);        // 顶面的第一个点        triangles.Add(topStartIndex + i);    // 当前拔高后的点        triangles.Add(topStartIndex + i + 1);// 下一个拔高后的点    &#125;    // 将顶点和三角形数据赋值给Mesh    shadowMesh.vertices = vertices.ToArray();    shadowMesh.triangles = triangles.ToArray();    shadowMesh.RecalculateNormals(); // 重新计算法线        // 添加碰撞体    MeshCollider meshCollider = shadowEntity.GetComponent&lt;MeshCollider&gt;();    if (meshCollider == null)    &#123;        meshCollider = shadowEntity.AddComponent&lt;MeshCollider&gt;();    &#125;    meshCollider.sharedMesh = shadowMesh; // 更新MeshCollider的网格&#125;\n"},{"url":"/2025/04/13/%E5%85%89%E5%BD%B1%E6%A1%A5%E9%80%94/","content":"\ntitle:光影桥途Demo比赛名称：[TapTap聚光灯挑战]举办时间：[2024.10.8 - 2024.10.29]比赛主题：[Light]  \n游戏概述《光影桥途》是一款类纪念碑谷的3D解谜游戏，玩家需要操控场景中的平行光源，利用投射的影子作为桥梁和互动元素，帮助角色从起点抵达终点。我们的游戏灵感来源于”光”这一主题，探索了光与影的互动关系以及它们如何改变我们对环境的感知。\n游戏特色\n光影互动机制：玩家可以通过调整平行光源的方向，改变特定物体投射的影子形状和位置\n影子即实体：游戏中的影子不仅是视觉效果，更是带有碰撞体的实体，可以作为角色行走的道路或与其他物体的互动媒介\n纪念碑谷式视角：采用3D正交视角，提供清晰的空间感知同时保持美学风格\n\n技术实现使用了以下技术和工具：\n\n游戏引擎：Unity\n编程语言：C#\n设计模式: 单例模式、订阅者模式等\n使用插件    ：DOTween, Shader Graph, Cinemachine等\n\n在开发过程中，最大的技术挑战是实现影子作为实体的物理碰撞系统。我们通过自定义的ShadowVolumeGenerator类解决了这一难题，该类能够：\n\n实时计算投影点：根据光源位置和物体顶点，计算出投影到地面上的点\n凸包算法处理：使用凸包算法确保生成的阴影形状合理且有效\n3D网格生成：将阴影投影点转换为带有高度的3D网格，包括底面、侧面和顶面\n碰撞体添加：为生成的阴影网格添加MeshCollider，使其成为可交互的游戏元素\n\n游戏截图\n\n\n\n实机视频比赛时用的宣传片\n\n  \n  Your browser does not support the video tag.\n\n\n一点小插曲其实灵感最初来源于这样一个笑话\n有两个人决定逃跑，因此他们爬到了屋子的房顶，他们看到了一片片的房顶，隔着一条窄窄的沟，延伸到城里，延伸到自由。第一个人直接跳了过去，毫无压力，但他的朋友不行，他太害怕摔下去！因此，第一个人想了个办法，他说：“嘿，我有个手电筒，我用它照射到房子间的沟，这样你就能踩着光走到我身边了，但是第二个人说：“你在开玩笑吗，当我走到一半的时候你就会把手电筒关掉！\n核心机制具体实现：ShadowVolumeGenerator1. 初始化public class ShadowVolumeGenerator : MonoBehaviour&#123;    public Light lightSource; // 光源    public float entityHeight = 1f; // 阴影实体的高度    public int maxShadowPoints = 1000; // 阴影点的最大数量限制    public List&lt;GameObject&gt; shadowCastingObjects; // 需要生成阴影的物体    public Plane groundPlane;    private List&lt;Vector3&gt; shadowPoints = new List&lt;Vector3&gt;(); // 存储阴影的投影点    private GameObject shadowEntity; // 存储阴影实体    public Material shadowMaterial; // 阴影材质    public GameObject groundPlaneObject;        void Start()    &#123;        // 创建阴影实体        shadowEntity = new GameObject(&quot;SingleShadowEntity&quot;);        shadowEntity.AddComponent&lt;MeshFilter&gt;();        MeshRenderer meshRenderer = shadowEntity.AddComponent&lt;MeshRenderer&gt;();        meshRenderer.material = shadowMaterial;    &#125;\n\n系统初始化时，会创建一个空的GameObject作为阴影实体的容器，并添加必要的渲染组件。这个容器将在后续用于存放生成的阴影网格。\n2. 实时阴影计算在每一帧，系统会根据光源位置、投射物体和地面平面，计算实时阴影：\nvoid Update()&#123;    if (groundPlaneObject == null) return;    // 获取平面的法线和位置    Vector3 planeNormal = groundPlaneObject.transform.up;    Vector3 planePoint = groundPlaneObject.transform.position;    // 定义一个平面    Plane groundPlane = new Plane(planeNormal, planePoint);    // 更新阴影    GenerateShadowUsingProjection(shadowCastingObjects, groundPlane);&#125;\n\n3. 阴影投影点计算阴影生成的第一步是计算物体在光照下投射到地面上的投影点：\nvoid GenerateShadowUsingProjection(List&lt;GameObject&gt; shadowCastingObjects, Plane groundPlane)&#123;    shadowPoints.Clear(); // 清空阴影点列表    foreach (var obj in shadowCastingObjects)    &#123;        MeshFilter meshFilter = obj.GetComponent&lt;MeshFilter&gt;();        if (meshFilter == null) continue;        Mesh mesh = meshFilter.mesh;        Vector3[] vertices = mesh.vertices;        for (int i = 0; i &lt; vertices.Length; i++)        &#123;            Vector3 worldVertex = obj.transform.TransformPoint(vertices[i]);                        Vector3 directionToLight = (worldVertex - lightSource.transform.position).normalized;            // 处理不同光源类型的阴影            if (lightSource.type == LightType.Directional)            &#123;                directionToLight = -lightSource.transform.forward;            &#125;            else if (lightSource.type == LightType.Point)            &#123;                directionToLight = -(worldVertex - lightSource.transform.position).normalized;            &#125;                        // 计算投影点到平面的投影            float distanceToPlane = groundPlane.GetDistanceToPoint(worldVertex);            Vector3 projectedPoint = worldVertex - directionToLight *                 (distanceToPlane / Vector3.Dot(directionToLight, groundPlane.normal));                       shadowPoints.Add(projectedPoint);                        // 达到最大投影点数量限制后跳出循环            if (shadowPoints.Count &gt;= maxShadowPoints)                break;        &#125;    &#125;    // 使用凸包算法处理投影点    shadowPoints = ConvexHull(shadowPoints);        // 如果有足够的点，生成阴影实体    if (shadowPoints.Count &gt; 2)    &#123;        GenerateShadowEntityWithHeight(shadowPoints, groundPlane.normal);    &#125;&#125;\n获取物体顶点：遍历每个需要投影的物体的所有顶点\n计算光照方向：根据光源类型（方向光、点光源）确定投影方向\n平面投影计算：使用平面方程计算顶点在任意平面上的投影点\n投影点收集：收集所有的投影点用于后续处理\n4. 凸包算法处理为了生成合理的阴影形状，这里使用了Graham扫描算法计算投影点的凸包：\nList&lt;Vector3&gt; ConvexHull(List&lt;Vector3&gt; points)&#123;    // 排序点，基于x和z坐标    points.Sort((a, b) =&gt;    &#123;        if (a.x == b.x) return a.z.CompareTo(b.z);        return a.x.CompareTo(b.x);    &#125;);    List&lt;Vector3&gt; hull = new List&lt;Vector3&gt;();    // 凸包的下部分    foreach (var p in points)    &#123;        while (hull.Count &gt;= 2 &amp;&amp; Cross(hull[hull.Count - 2], hull[hull.Count - 1], p) &lt;= 0)        &#123;            hull.RemoveAt(hull.Count - 1);        &#125;        hull.Add(p);    &#125;    // 凸包的上部分    int t = hull.Count + 1;    for (int i = points.Count - 2; i &gt;= 0; i--)    &#123;        var p = points[i];        while (hull.Count &gt;= t &amp;&amp; Cross(hull[hull.Count - 2], hull[hull.Count - 1], p) &lt;= 0)        &#123;            hull.RemoveAt(hull.Count - 1);        &#125;        hull.Add(p);    &#125;    hull.RemoveAt(hull.Count - 1);  // 移除重复的起点    return hull;&#125;// 计算叉积，判断三点形成的转向float Cross(Vector3 o, Vector3 a, Vector3 b)&#123;    return (a.x - o.x) * (b.z - o.z) - (a.z - o.z) * (b.x - o.x);&#125;\n\n5. 阴影实体网格生成最后，系统将投影点转换为完整的3D网格，包括底面、侧面和顶面：\nvoid GenerateShadowEntityWithHeight(List&lt;Vector3&gt; shadowPoints, Vector3 planeNormal)&#123;    MeshFilter meshFilter = shadowEntity.GetComponent&lt;MeshFilter&gt;();    Mesh shadowMesh = new Mesh();    meshFilter.mesh = shadowMesh;    List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();    vertices.AddRange(shadowPoints); // 地面上的阴影投影点        // 添加顶部顶点    foreach (Vector3 point in shadowPoints)    &#123;        vertices.Add(point + planeNormal * entityHeight); // 在法线方向上拔高    &#125;    // 生成底面的三角形    List&lt;int&gt; triangles = new List&lt;int&gt;();    for (int i = 1; i &lt; shadowPoints.Count - 1; i++)    &#123;        triangles.Add(0);       // 第一个顶点        triangles.Add(i);       // 当前顶点        triangles.Add(i + 1);   // 下一个顶点    &#125;    // 生成侧面的三角形    int topStartIndex = shadowPoints.Count;  // 拔高顶点的起始索引    for (int i = 0; i &lt; shadowPoints.Count; i++)    &#123;        int nextIndex = (i + 1) % shadowPoints.Count;        // 连接底部和顶部的顶点，生成侧面        triangles.Add(i);                 // 底面顶点        triangles.Add(nextIndex);         // 下一个底面顶点        triangles.Add(topStartIndex + i); // 对应的顶部顶点        triangles.Add(topStartIndex + i);         // 顶部顶点        triangles.Add(nextIndex);                 // 下一个底面顶点        triangles.Add(topStartIndex + nextIndex); // 对应的顶部顶点    &#125;    // 生成顶面的三角形    for (int i = 1; i &lt; shadowPoints.Count - 1; i++)    &#123;        triangles.Add(topStartIndex);        // 顶面的第一个点        triangles.Add(topStartIndex + i);    // 当前拔高后的点        triangles.Add(topStartIndex + i + 1);// 下一个拔高后的点    &#125;    // 将顶点和三角形数据赋值给Mesh    shadowMesh.vertices = vertices.ToArray();    shadowMesh.triangles = triangles.ToArray();    shadowMesh.RecalculateNormals(); // 重新计算法线        // 添加碰撞体    MeshCollider meshCollider = shadowEntity.GetComponent&lt;MeshCollider&gt;();    if (meshCollider == null)    &#123;        meshCollider = shadowEntity.AddComponent&lt;MeshCollider&gt;();    &#125;    meshCollider.sharedMesh = shadowMesh; // 更新MeshCollider的网格&#125;\n"}]