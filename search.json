[{"title":"光影桥途Demo","url":"/2025/04/13/%E5%85%89%E5%BD%B1%E6%A1%A5%E9%80%94/","content":"\nTapTap聚光灯挑战的参赛Demo\n\n比赛名称：[TapTap聚光灯挑战]举办时间：[2024.10.8 - 2024.10.29]比赛主题：[Light]  \n光影桥途 Demo游戏概述《光影桥途》是一款类纪念碑谷的3D解谜Demo，是我在TapTap聚光灯挑战的团队开发作品，在玩家需要操控场景中的平行光源，利用物体投射的影子作为桥梁和互动元素，帮助角色抵达终点。我们的游戏灵感来源于”Light”作为”光”的这一语义，探索了光与影的互动关系以及它们如何改变我们对环境的感知。\n游戏特色\n光影互动机制：玩家可以通过调整平行光源的方向，改变特定物体投射的影子形状和位置\n影子即实体：游戏中的影子不仅是视觉效果，更是带有碰撞体的实体，可以作为角色行走的道路或与其他物体的互动媒介\n纪念碑谷式视角：采用3D正交视角，提供清晰的空间感知，主要采用纯色几何体和高度雾作为视觉呈现。\n\n技术实现使用了以下技术和工具：\n\n游戏引擎：Unity\n编程语言：C#\n设计模式: 单例模式、订阅者模式等\n使用插件    ：DOTween, Shader Graph等\n\n个人主要负责部分1.实现影子实体的生成和物理碰撞系统，主要使用ShadowVolumeGenerator类，该类能够：\n\n实时计算投影点：根据光源位置和物体顶点，计算出投影到地面上的点\n凸包算法处理：使用凸包算法确保生成的阴影形状合理且有效\n3D网格生成：将阴影投影点转换为带有高度的3D网格，包括底面、侧面和顶面\n碰撞体添加：为生成的阴影网格添加MeshCollider，使其成为可交互的游戏元素\n\n2.实现摄像机转向控制，基于Scriptable Object的存档系统，借助DotWeen实现的游戏内UI及动画3.使用ShaderGraph实现正交视角下的高度雾\n游戏截图\n\n\n\n实机视频比赛时用的宣传片\n\n  \n  Your browser does not support the video tag.\n\n\n一点小插曲其实灵感最初来源于这样一个笑话\n有两个人决定逃跑，因此他们爬到了屋子的房顶，他们看到了一片片的房顶，隔着一条窄窄的沟，延伸到城里，延伸到自由。第一个人直接跳了过去，毫无压力，但他的朋友不行，他太害怕摔下去！因此，第一个人想了个办法，他说：“嘿，我有个手电筒，我用它照射到房子间的沟，这样你就能踩着光走到我身边了，但是第二个人说：“你在开玩笑吗，当我走到一半的时候你就会把手电筒关掉！\n核心机制具体实现：ShadowVolumeGenerator1. 初始化public class ShadowVolumeGenerator : MonoBehaviour&#123;    public Light lightSource; // 光源    public float entityHeight = 1f; // 阴影实体的高度    public int maxShadowPoints = 1000; // 阴影点的最大数量限制    public List&lt;GameObject&gt; shadowCastingObjects; // 需要生成阴影的物体    public Plane groundPlane;    private List&lt;Vector3&gt; shadowPoints = new List&lt;Vector3&gt;(); // 存储阴影的投影点    private GameObject shadowEntity; // 存储阴影实体    public Material shadowMaterial; // 阴影材质    public GameObject groundPlaneObject;        void Start()    &#123;        // 创建阴影实体        shadowEntity = new GameObject(&quot;SingleShadowEntity&quot;);        shadowEntity.AddComponent&lt;MeshFilter&gt;();        MeshRenderer meshRenderer = shadowEntity.AddComponent&lt;MeshRenderer&gt;();        meshRenderer.material = shadowMaterial;    &#125;\n\n系统初始化时，会创建一个空的GameObject作为阴影实体的容器，并添加必要的渲染组件。这个容器将在后续用于存放生成的阴影网格。\n2. 实时阴影计算在每一帧，系统会根据光源位置、投射物体和地面平面，计算实时阴影：\nvoid Update()&#123;    if (groundPlaneObject == null) return;    // 获取平面的法线和位置    Vector3 planeNormal = groundPlaneObject.transform.up;    Vector3 planePoint = groundPlaneObject.transform.position;    // 定义一个平面    Plane groundPlane = new Plane(planeNormal, planePoint);    // 更新阴影    GenerateShadowUsingProjection(shadowCastingObjects, groundPlane);&#125;\n\n3. 阴影投影点计算阴影生成的第一步是计算物体在光照下投射到地面上的投影点：\nvoid GenerateShadowUsingProjection(List&lt;GameObject&gt; shadowCastingObjects, Plane groundPlane)&#123;    shadowPoints.Clear(); // 清空阴影点列表    foreach (var obj in shadowCastingObjects)    &#123;        MeshFilter meshFilter = obj.GetComponent&lt;MeshFilter&gt;();        if (meshFilter == null) continue;        Mesh mesh = meshFilter.mesh;        Vector3[] vertices = mesh.vertices;        for (int i = 0; i &lt; vertices.Length; i++)        &#123;            Vector3 worldVertex = obj.transform.TransformPoint(vertices[i]);                        Vector3 directionToLight = (worldVertex - lightSource.transform.position).normalized;            // 处理不同光源类型的阴影            if (lightSource.type == LightType.Directional)            &#123;                directionToLight = -lightSource.transform.forward;            &#125;            else if (lightSource.type == LightType.Point)            &#123;                directionToLight = -(worldVertex - lightSource.transform.position).normalized;            &#125;                        // 计算投影点到平面的投影            float distanceToPlane = groundPlane.GetDistanceToPoint(worldVertex);            Vector3 projectedPoint = worldVertex - directionToLight *                 (distanceToPlane / Vector3.Dot(directionToLight, groundPlane.normal));                       shadowPoints.Add(projectedPoint);                        // 达到最大投影点数量限制后跳出循环            if (shadowPoints.Count &gt;= maxShadowPoints)                break;        &#125;    &#125;    // 使用凸包算法处理投影点    shadowPoints = ConvexHull(shadowPoints);        // 如果有足够的点，生成阴影实体    if (shadowPoints.Count &gt; 2)    &#123;        GenerateShadowEntityWithHeight(shadowPoints, groundPlane.normal);    &#125;&#125;\n获取物体顶点：遍历每个需要投影的物体的所有顶点\n计算光照方向：根据光源类型（方向光、点光源）确定投影方向\n平面投影计算：使用平面方程计算顶点在任意平面上的投影点\n投影点收集：收集所有的投影点用于后续处理\n4. 凸包算法处理为了生成合理的阴影形状，这里使用了Graham扫描算法计算投影点的凸包：\nList&lt;Vector3&gt; ConvexHull(List&lt;Vector3&gt; points)&#123;    // 排序点，基于x和z坐标    points.Sort((a, b) =&gt;    &#123;        if (a.x == b.x) return a.z.CompareTo(b.z);        return a.x.CompareTo(b.x);    &#125;);    List&lt;Vector3&gt; hull = new List&lt;Vector3&gt;();    // 凸包的下部分    foreach (var p in points)    &#123;        while (hull.Count &gt;= 2 &amp;&amp; Cross(hull[hull.Count - 2], hull[hull.Count - 1], p) &lt;= 0)        &#123;            hull.RemoveAt(hull.Count - 1);        &#125;        hull.Add(p);    &#125;    // 凸包的上部分    int t = hull.Count + 1;    for (int i = points.Count - 2; i &gt;= 0; i--)    &#123;        var p = points[i];        while (hull.Count &gt;= t &amp;&amp; Cross(hull[hull.Count - 2], hull[hull.Count - 1], p) &lt;= 0)        &#123;            hull.RemoveAt(hull.Count - 1);        &#125;        hull.Add(p);    &#125;    hull.RemoveAt(hull.Count - 1);  // 移除重复的起点    return hull;&#125;// 计算叉积，判断三点形成的转向float Cross(Vector3 o, Vector3 a, Vector3 b)&#123;    return (a.x - o.x) * (b.z - o.z) - (a.z - o.z) * (b.x - o.x);&#125;\n\n5. 阴影实体网格生成最后，系统将投影点转换为完整的3D网格，包括底面、侧面和顶面：\nvoid GenerateShadowEntityWithHeight(List&lt;Vector3&gt; shadowPoints, Vector3 planeNormal)&#123;    MeshFilter meshFilter = shadowEntity.GetComponent&lt;MeshFilter&gt;();    Mesh shadowMesh = new Mesh();    meshFilter.mesh = shadowMesh;    List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;();    vertices.AddRange(shadowPoints); // 地面上的阴影投影点        // 添加顶部顶点    foreach (Vector3 point in shadowPoints)    &#123;        vertices.Add(point + planeNormal * entityHeight); // 在法线方向上拔高    &#125;    // 生成底面的三角形    List&lt;int&gt; triangles = new List&lt;int&gt;();    for (int i = 1; i &lt; shadowPoints.Count - 1; i++)    &#123;        triangles.Add(0);       // 第一个顶点        triangles.Add(i);       // 当前顶点        triangles.Add(i + 1);   // 下一个顶点    &#125;    // 生成侧面的三角形    int topStartIndex = shadowPoints.Count;  // 拔高顶点的起始索引    for (int i = 0; i &lt; shadowPoints.Count; i++)    &#123;        int nextIndex = (i + 1) % shadowPoints.Count;        // 连接底部和顶部的顶点，生成侧面        triangles.Add(i);                 // 底面顶点        triangles.Add(nextIndex);         // 下一个底面顶点        triangles.Add(topStartIndex + i); // 对应的顶部顶点        triangles.Add(topStartIndex + i);         // 顶部顶点        triangles.Add(nextIndex);                 // 下一个底面顶点        triangles.Add(topStartIndex + nextIndex); // 对应的顶部顶点    &#125;    // 生成顶面的三角形    for (int i = 1; i &lt; shadowPoints.Count - 1; i++)    &#123;        triangles.Add(topStartIndex);        // 顶面的第一个点        triangles.Add(topStartIndex + i);    // 当前拔高后的点        triangles.Add(topStartIndex + i + 1);// 下一个拔高后的点    &#125;    // 将顶点和三角形数据赋值给Mesh    shadowMesh.vertices = vertices.ToArray();    shadowMesh.triangles = triangles.ToArray();    shadowMesh.RecalculateNormals(); // 重新计算法线        // 添加碰撞体    MeshCollider meshCollider = shadowEntity.GetComponent&lt;MeshCollider&gt;();    if (meshCollider == null)    &#123;        meshCollider = shadowEntity.AddComponent&lt;MeshCollider&gt;();    &#125;    meshCollider.sharedMesh = shadowMesh; // 更新MeshCollider的网格&#125;\n","categories":["GameJam"],"tags":["Demo"]},{"title":"艾德里安的梦境Demo","url":"/2025/04/14/%E8%89%BE%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E5%A2%83/","content":"吉比特高校Game挑战赛的参赛Demo\n\n比赛名称：[吉比特高校GameJam挑战赛]举办时间：[2024.11.21 - 2024.12.1]比赛主题：[梦境]  \n艾德里安的梦境 Demo《艾德里安的梦境》（Adrian’s Dream） 是我在 吉比特高校 Game Jam 挑战赛 上团队开发的Demo，有幸获得本次 Game Jam 挑战赛的 北京奖！虽然Demo整体较为简陋，但这还是第一次拿到奖项，作为主催和程序，在这里写一篇博客来记录一下。\n《艾德里安的梦境》《艾德里安的梦境》是一款 2.5D 视角的探索解谜Demo。故事发生在一个抽象的“意识空间”里。玩家醒来时发现自己失去了记忆，唯一的任务似乎就是探索眼前这个破碎的世界，通过进入代表主人公安德里安·克莱斯特（Adrian Klester）童年、中年、老年的不同房间，拼凑出他的人生片段。\n个人主要负责部分：Gameplay 程序负责核心 Gameplay 机制编程实现：\n搭建了游戏的基础框架（基于单例的Manager），实现了玩家角色的 2.5D 移动控制 (A&#x2F;D 键移动) 及交互逻辑，配置并实现了基于 Cinemachine 的动态摄像机跟随。\n\n开发了基于 Raycast 的环境交互系统，支持玩家与场景元素互动，包括：物品tooltip信息，谜题机关的触发逻辑，交互对象的高亮视觉反馈（例如通过材质变更实现）等。\n\n负责实现了游戏前两个核心关卡（对应现实和艾德里安的童年阶段）的主要游戏流程，将核心移动、交互、解谜与日志系统有效整合，驱动关卡叙事与玩家进程。\n\n\n负责 UI 与系统功能实现：\n开发了游戏内的基础 UI 界面及交互功能，包括终端中的电子日记，日志系统UI。\n\n重点实现了核心的日志 (Log) 系统 ，允许玩家收集、存储并随时查阅在探索过程中发现的关键线索，有效支撑了游戏的叙事解谜玩法。\n\n\n担任PM与项目协调人：\n积极协调团队内程序、美术、策划等不同职能成员间的沟通与协作，统合成员意见，明确任务分工。\n\n推动项目进度，制定任务时间表，确保各项任务在 Game Jam 的时间限制内有效对接与整合。\n\n\n游戏特色\n情感叙事： 探讨爱、失落、恐惧与自我认同等主题。\n\n非线性叙事： 梦境世界可依不同顺序探索，拼凑碎片化的真相。\n\n创新界面设计： 游戏UI界面不仅是游戏元素，也承载叙事意义，是达成结局的重要部分，探讨艺术与科技之间的关系，通过艾德里安的经历展现两者交融。\n\n游戏引擎：Unity\n\n编程语言：C#\n\n设计模式: 单例模式、订阅者模式等\n\n使用插件：Cinemachine, Amplify Shader Editor等\n\n\n核心玩法：探索、解谜与时空切换游戏的核心玩法围绕着以下几个方面展开：\n\n探索与互动： 玩家需要在不同的房间场景中自由探索，与环境中的各种物品进行互动（使用鼠标）。\n环境解谜： 通过收集物品、发现线索、完成迷你游戏（比如我们在 Demo 中设计的密码锁等），解开阻碍前进的谜题。\n线索收集与日志： 找到的关键线索和信息会被记录在游戏内置的日志系统（Log System）中，帮助玩家梳理剧情和解谜思路。\n梦境&#x2F;现实切换： 这是我们设计的一个核心机制。玩家可以通过与特定物品（闹钟）互动，在色彩温暖、充满象征意义的“梦境”和色调冰冷、更接近现实残酷的“现实”两个状态间切换。这种切换不仅改变视觉呈现，也可能揭示新的线索或改变可互动的对象，是解开某些谜题的关键。\n\n故事内核：记忆、身份与意识的迷宫表面上看，玩家似乎是在扮演安德里安本人，重温他的人生。但随着探索的深入，你会发现事情远没有那么简单。\n游戏想要探讨的主题包括：记忆的不可靠性、身份认同的挣扎、意识的本质、爱与失去、对未知的恐惧以及科技（特别是意识上传&#x2F;转移）可能带来的伦理困境。\n最大的悬念在于 “我是谁？”。玩家最终会意识到，自己可能并非真正的安德里安，而是一个承载他记忆的“容器”或“意识副本”，是在一项实验性的意识转移项目中诞生的存在。这个发现将引导玩家重新审视自己经历的一切，并对自我存在的意义产生疑问。\n\n艺术风格：梦核与现实的反差我们采用了 2.5D 的视角，在视觉风格上，我们追求一种 梦境（Dreamcore） 的感觉，尤其是在代表不同人生阶段的“梦境”场景中：\n\n童年房间： 温暖、略带怀旧的色调。\n\n\n\n中年房间： 可能更偏向浪漫或理想化的色彩。\n\n\n\n老年房间： 色调趋于冷静甚至冰冷。\n\n\n与之相对，“现实”场景则采用了更灰暗、硬朗的视觉元素，用以突出梦境与现实的割裂感，以及故事背后可能隐藏的冰冷真相。\n开发回顾与感悟作为主要开发者之一，参与这次吉比特 Game Jam 是一次极其难忘的经历。在有限的时间和队友们一起从零开始构思、设计、开发并最终完成《艾德里安的梦境》Demo，充满了挑战和乐趣。\n能够获得北京站奖，是对我们团队努力的巨大肯定。虽然这只是一个 Game Jam 的 Demo，还有很多可以打磨和扩展的地方，但它承载了我们对于游戏叙事、玩法机制和主题表达的思考与尝试。\n\n感谢您的阅读！希望通过这篇介绍，能让你对《艾德里安的梦境》有一个更深入的了解。如果你对这款 Demo 有更深入了解的想法，可以在以下链接获得更多信息！\n【【吉比特高校GameJam挑战赛】吉比特GameJam参赛作品：《艾德里安的梦境》（全流程，剧透警告）】 https://www.bilibili.com/video/BV1ajzZYREtV/?share_source=copy_web&amp;vd_source=62f4f84329f0ab3d51a83f6570b3edf1\n游戏本体：https://pan.baidu.com/s/18PdjiEUVPL1O37GbW_OlHA?pwd=yja7#list/path=%2F&amp;parentPath=%2F\n","categories":["GameJam"],"tags":["Demo"]},{"title":"基于战双帕弥什角色的PBR+NPR渲染","url":"/2025/04/14/%E6%88%98%E5%8F%8CNPR/","content":"一次尝试\n\n基于战双帕弥什角色的PBR+NPR渲染\n\n引擎:Unity\n渲染管线:Urp 14.0.10 \n采用forwardRendering 前向渲染管线\n\n核心渲染特性:\n物理基础光照 (PBR): 实现了基于 Albedo、Normal Map、PBR Mask (Roughness&#x2F;Metallic&#x2F;AO) 的物理基础光照计算，采用 Cook-Torrence BRDF 模型，确保光照的真实感。\n\nNPR 风格阴影: 集成了多级阴影控制 (No Shadow, First Shadow, Second Shadow)，并支持阈值、颜色及平滑过渡 (Smooth Shadow) 的自定义，增强卡通渲染的风格化表现。\n\n可定制高光: 开发了可定制的高光 (Specular) 模型，允许调整强度、光泽度 (Shininess)、颜色、平滑因子及阴影衰减，灵活控制高光效果。\n\n边缘光 (Rim Light) 控制\n\n环境反射: 支持 Cubemap 环境反射，并可选择性应用旋转，提升场景融入感。\n\n自发光与辉光: 整合了自发光 (Emission) 和辉光 (Bloom) 效果控制，并支持 Flow Map 驱动的动态自发光效果。\n\n脸部 SDF 渲染: 针对角色脸部实现了 SDF (Signed Distance Field) 渲染技术，以优化面部细节表现。\n\n专用皮肤着色: 开发了专用的皮肤着色模型，通过 _SkinRamp 纹理实现细腻的卡通肤色过渡，并结合顶点颜色和 Ramp 图进行混合，支持多层皮肤颜色混合。\n\n顶点扩展轮廓线: 采用基于顶点法线和视距扩展 (Vertex Extrusion) 的方法生成轮廓线 ，并实现了轮廓线宽度、颜色等参数的可调性。同时，加入了基于距离的轮廓线宽度缩放 和 Z 轴偏移,同时利用顶点颜色的R通道discard片元以优化显示效果。后期处理: 在后期处理 (PostProcessing.hlsl) 中实现了屏幕空间的颜色调整 (曝光、对比度) 和基于用户自定义 LUT 的色彩分级 (Color Grading)。\n\n\n    Your browser does not support the video tag.\n未完成部分\n各向异性发丝高光\n头发眼透\n皮肤受光表现\n\n","categories":["TA"],"tags":["-TA"]}]