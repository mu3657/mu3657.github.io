<!DOCTYPE html><html lang="cn" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>光影桥途Demo | Hexo</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.woff2"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","code_fold":15,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>光影桥途Demo</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-04-13T09:00:30.666Z" id="date"> 2025-04-13</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-04-14T08:58:31.641Z" id="updated"> 2025-04-14</time></div></span></div></div><hr><div id="post-content"><p><strong>比赛名称</strong>：[TapTap聚光灯挑战]<br><strong>举办时间</strong>：[2024.10.8 - 2024.10.29]<br><strong>比赛主题</strong>：[Light]  </p>
<h1 id="光影桥途-Demo"><a href="#光影桥途-Demo" class="headerlink" title="光影桥途 Demo"></a>光影桥途 Demo</h1><h3 id="游戏概述"><a href="#游戏概述" class="headerlink" title="游戏概述"></a>游戏概述</h3><p>《光影桥途》是一款类纪念碑谷的3D解谜游戏，玩家需要操控场景中的平行光源，利用投射的影子作为桥梁和互动元素，帮助角色从起点抵达终点。我们的游戏灵感来源于”光”这一主题，探索了光与影的互动关系以及它们如何改变我们对环境的感知。</p>
<h3 id="游戏特色"><a href="#游戏特色" class="headerlink" title="游戏特色"></a>游戏特色</h3><ul>
<li><strong>光影互动机制</strong>：玩家可以通过调整平行光源的方向，改变特定物体投射的影子形状和位置</li>
<li><strong>影子即实体</strong>：游戏中的影子不仅是视觉效果，更是带有碰撞体的实体，可以作为角色行走的道路或与其他物体的互动媒介</li>
<li><strong>纪念碑谷式视角</strong>：采用3D正交视角，提供清晰的空间感知同时保持美学风格</li>
</ul>
<h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><p>使用了以下技术和工具：</p>
<ul>
<li><strong>游戏引擎</strong>：Unity</li>
<li><strong>编程语言</strong>：C#</li>
<li><strong>设计模式</strong>: 单例模式、订阅者模式等</li>
<li><strong>使用插件</strong>    ：DOTween, Shader Graph, Cinemachine等</li>
</ul>
<h3 id="个人主要负责部分"><a href="#个人主要负责部分" class="headerlink" title="个人主要负责部分"></a>个人主要负责部分</h3><p>1.实现影子实体的生成和物理碰撞系统，主要使用<code>ShadowVolumeGenerator</code>类，该类能够：</p>
<ul>
<li><strong>实时计算投影点</strong>：根据光源位置和物体顶点，计算出投影到地面上的点</li>
<li><strong>凸包算法处理</strong>：使用凸包算法确保生成的阴影形状合理且有效</li>
<li><strong>3D网格生成</strong>：将阴影投影点转换为带有高度的3D网格，包括底面、侧面和顶面</li>
<li><strong>碰撞体添加</strong>：为生成的阴影网格添加MeshCollider，使其成为可交互的游戏元素</li>
</ul>
<ol start="2">
<li></li>
</ol>
<h3 id="游戏截图"><a href="#游戏截图" class="headerlink" title="游戏截图"></a>游戏截图</h3><p class='item-img' data-src='/images/image-1.png'><img src="/images/image-1.png" alt="alt text"></p>
<p class='item-img' data-src='/images/dc9db871d22ea170ea9f71ab5cfb7f03.png'><img src="/images/dc9db871d22ea170ea9f71ab5cfb7f03.png" alt="alt text"></p>
<p class='item-img' data-src='/images/238e5cce550ad01838b8eb318d6568be.png'><img src="/images/238e5cce550ad01838b8eb318d6568be.png" alt="alt text"></p>
<p class='item-img' data-src='/images/image.png'><img src="/images/image.png" alt="alt text"></p>
<h3 id="实机视频"><a href="#实机视频" class="headerlink" title="实机视频"></a>实机视频</h3><p><em>比赛时用的宣传片</em></p>
<video width="1280" height="720" controls>
  <source src="/images/宣传片.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

<h3 id="一点小插曲"><a href="#一点小插曲" class="headerlink" title="一点小插曲"></a>一点小插曲</h3><p>其实灵感最初来源于这样一个笑话</p>
<p>有两个人决定逃跑，因此他们爬到了屋子的房顶，他们看到了一片片的房顶，隔着一条窄窄的沟，延伸到城里，延伸到自由。第一个人直接跳了过去，毫无压力，但他的朋友不行，他太害怕摔下去！因此，第一个人想了个办法，他说：“嘿，我有个手电筒，我用它照射到房子间的沟，这样你就能踩着光走到我身边了，但是第二个人说：“你在开玩笑吗，当我走到一半的时候你就会把手电筒关掉！</p>
<h3 id="核心机制具体实现：ShadowVolumeGenerator"><a href="#核心机制具体实现：ShadowVolumeGenerator" class="headerlink" title="核心机制具体实现：ShadowVolumeGenerator"></a>核心机制具体实现：ShadowVolumeGenerator</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShadowVolumeGenerator</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Light lightSource; <span class="hljs-comment">// 光源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> entityHeight = <span class="hljs-number">1f</span>; <span class="hljs-comment">// 阴影实体的高度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxShadowPoints = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 阴影点的最大数量限制</span><br>    <span class="hljs-keyword">public</span> List&lt;GameObject&gt; shadowCastingObjects; <span class="hljs-comment">// 需要生成阴影的物体</span><br>    <span class="hljs-keyword">public</span> Plane groundPlane;<br>    <span class="hljs-keyword">private</span> List&lt;Vector3&gt; shadowPoints = <span class="hljs-keyword">new</span> List&lt;Vector3&gt;(); <span class="hljs-comment">// 存储阴影的投影点</span><br>    <span class="hljs-keyword">private</span> GameObject shadowEntity; <span class="hljs-comment">// 存储阴影实体</span><br>    <span class="hljs-keyword">public</span> Material shadowMaterial; <span class="hljs-comment">// 阴影材质</span><br>    <span class="hljs-keyword">public</span> GameObject groundPlaneObject;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建阴影实体</span><br>        shadowEntity = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;SingleShadowEntity&quot;</span>);<br>        shadowEntity.AddComponent&lt;MeshFilter&gt;();<br>        MeshRenderer meshRenderer = shadowEntity.AddComponent&lt;MeshRenderer&gt;();<br>        meshRenderer.material = shadowMaterial;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>系统初始化时，会创建一个空的GameObject作为阴影实体的容器，并添加必要的渲染组件。这个容器将在后续用于存放生成的阴影网格。</p>
<h4 id="2-实时阴影计算"><a href="#2-实时阴影计算" class="headerlink" title="2. 实时阴影计算"></a>2. 实时阴影计算</h4><p>在每一帧，系统会根据光源位置、投射物体和地面平面，计算实时阴影：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (groundPlaneObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 获取平面的法线和位置</span><br>    Vector3 planeNormal = groundPlaneObject.transform.up;<br>    Vector3 planePoint = groundPlaneObject.transform.position;<br><br>    <span class="hljs-comment">// 定义一个平面</span><br>    Plane groundPlane = <span class="hljs-keyword">new</span> Plane(planeNormal, planePoint);<br><br>    <span class="hljs-comment">// 更新阴影</span><br>    GenerateShadowUsingProjection(shadowCastingObjects, groundPlane);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-阴影投影点计算"><a href="#3-阴影投影点计算" class="headerlink" title="3. 阴影投影点计算"></a>3. 阴影投影点计算</h4><p>阴影生成的第一步是计算物体在光照下投射到地面上的投影点：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateShadowUsingProjection</span>(<span class="hljs-params">List&lt;GameObject&gt; shadowCastingObjects, Plane groundPlane</span>)</span><br>&#123;<br>    shadowPoints.Clear(); <span class="hljs-comment">// 清空阴影点列表</span><br><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> obj <span class="hljs-keyword">in</span> shadowCastingObjects)<br>    &#123;<br>        MeshFilter meshFilter = obj.GetComponent&lt;MeshFilter&gt;();<br>        <span class="hljs-keyword">if</span> (meshFilter == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br><br>        Mesh mesh = meshFilter.mesh;<br>        Vector3[] vertices = mesh.vertices;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices.Length; i++)<br>        &#123;<br>            Vector3 worldVertex = obj.transform.TransformPoint(vertices[i]);<br>            <br>            Vector3 directionToLight = (worldVertex - lightSource.transform.position).normalized;<br><br>            <span class="hljs-comment">// 处理不同光源类型的阴影</span><br>            <span class="hljs-keyword">if</span> (lightSource.type == LightType.Directional)<br>            &#123;<br>                directionToLight = -lightSource.transform.forward;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lightSource.type == LightType.Point)<br>            &#123;<br>                directionToLight = -(worldVertex - lightSource.transform.position).normalized;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 计算投影点到平面的投影</span><br>            <span class="hljs-built_in">float</span> distanceToPlane = groundPlane.GetDistanceToPoint(worldVertex);<br>            Vector3 projectedPoint = worldVertex - directionToLight * <br>                (distanceToPlane / Vector3.Dot(directionToLight, groundPlane.normal));<br>           <br>            shadowPoints.Add(projectedPoint);<br>            <br>            <span class="hljs-comment">// 达到最大投影点数量限制后跳出循环</span><br>            <span class="hljs-keyword">if</span> (shadowPoints.Count &gt;= maxShadowPoints)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用凸包算法处理投影点</span><br>    shadowPoints = ConvexHull(shadowPoints);<br>    <br>    <span class="hljs-comment">// 如果有足够的点，生成阴影实体</span><br>    <span class="hljs-keyword">if</span> (shadowPoints.Count &gt; <span class="hljs-number">2</span>)<br>    &#123;<br>        GenerateShadowEntityWithHeight(shadowPoints, groundPlane.normal);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>获取物体顶点：遍历每个需要投影的物体的所有顶点</p>
<p>计算光照方向：根据光源类型（方向光、点光源）确定投影方向</p>
<p>平面投影计算：使用平面方程计算顶点在任意平面上的投影点</p>
<p>投影点收集：收集所有的投影点用于后续处理</p>
<h4 id="4-凸包算法处理"><a href="#4-凸包算法处理" class="headerlink" title="4. 凸包算法处理"></a>4. 凸包算法处理</h4><p>为了生成合理的阴影形状，这里使用了Graham扫描算法计算投影点的凸包：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">List&lt;Vector3&gt; <span class="hljs-title">ConvexHull</span>(<span class="hljs-params">List&lt;Vector3&gt; points</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 排序点，基于x和z坐标</span><br>    points.Sort((a, b) =&gt;<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a.x == b.x) <span class="hljs-keyword">return</span> a.z.CompareTo(b.z);<br>        <span class="hljs-keyword">return</span> a.x.CompareTo(b.x);<br>    &#125;);<br><br>    List&lt;Vector3&gt; hull = <span class="hljs-keyword">new</span> List&lt;Vector3&gt;();<br><br>    <span class="hljs-comment">// 凸包的下部分</span><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> points)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (hull.Count &gt;= <span class="hljs-number">2</span> &amp;&amp; Cross(hull[hull.Count - <span class="hljs-number">2</span>], hull[hull.Count - <span class="hljs-number">1</span>], p) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            hull.RemoveAt(hull.Count - <span class="hljs-number">1</span>);<br>        &#125;<br>        hull.Add(p);<br>    &#125;<br><br>    <span class="hljs-comment">// 凸包的上部分</span><br>    <span class="hljs-built_in">int</span> t = hull.Count + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = points.Count - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">var</span> p = points[i];<br>        <span class="hljs-keyword">while</span> (hull.Count &gt;= t &amp;&amp; Cross(hull[hull.Count - <span class="hljs-number">2</span>], hull[hull.Count - <span class="hljs-number">1</span>], p) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            hull.RemoveAt(hull.Count - <span class="hljs-number">1</span>);<br>        &#125;<br>        hull.Add(p);<br>    &#125;<br><br>    hull.RemoveAt(hull.Count - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 移除重复的起点</span><br>    <span class="hljs-keyword">return</span> hull;<br>&#125;<br><br><span class="hljs-comment">// 计算叉积，判断三点形成的转向</span><br><span class="hljs-function"><span class="hljs-built_in">float</span> <span class="hljs-title">Cross</span>(<span class="hljs-params">Vector3 o, Vector3 a, Vector3 b</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (a.x - o.x) * (b.z - o.z) - (a.z - o.z) * (b.x - o.x);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-阴影实体网格生成"><a href="#5-阴影实体网格生成" class="headerlink" title="5. 阴影实体网格生成"></a>5. 阴影实体网格生成</h4><p>最后，系统将投影点转换为完整的3D网格，包括底面、侧面和顶面：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateShadowEntityWithHeight</span>(<span class="hljs-params">List&lt;Vector3&gt; shadowPoints, Vector3 planeNormal</span>)</span><br>&#123;<br>    MeshFilter meshFilter = shadowEntity.GetComponent&lt;MeshFilter&gt;();<br>    Mesh shadowMesh = <span class="hljs-keyword">new</span> Mesh();<br>    meshFilter.mesh = shadowMesh;<br><br>    List&lt;Vector3&gt; vertices = <span class="hljs-keyword">new</span> List&lt;Vector3&gt;();<br>    vertices.AddRange(shadowPoints); <span class="hljs-comment">// 地面上的阴影投影点</span><br>    <br>    <span class="hljs-comment">// 添加顶部顶点</span><br>    <span class="hljs-keyword">foreach</span> (Vector3 point <span class="hljs-keyword">in</span> shadowPoints)<br>    &#123;<br>        vertices.Add(point + planeNormal * entityHeight); <span class="hljs-comment">// 在法线方向上拔高</span><br>    &#125;<br><br>    <span class="hljs-comment">// 生成底面的三角形</span><br>    List&lt;<span class="hljs-built_in">int</span>&gt; triangles = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; shadowPoints.Count - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        triangles.Add(<span class="hljs-number">0</span>);       <span class="hljs-comment">// 第一个顶点</span><br>        triangles.Add(i);       <span class="hljs-comment">// 当前顶点</span><br>        triangles.Add(i + <span class="hljs-number">1</span>);   <span class="hljs-comment">// 下一个顶点</span><br>    &#125;<br><br>    <span class="hljs-comment">// 生成侧面的三角形</span><br>    <span class="hljs-built_in">int</span> topStartIndex = shadowPoints.Count;  <span class="hljs-comment">// 拔高顶点的起始索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; shadowPoints.Count; i++)<br>    &#123;<br>        <span class="hljs-built_in">int</span> nextIndex = (i + <span class="hljs-number">1</span>) % shadowPoints.Count;<br><br>        <span class="hljs-comment">// 连接底部和顶部的顶点，生成侧面</span><br>        triangles.Add(i);                 <span class="hljs-comment">// 底面顶点</span><br>        triangles.Add(nextIndex);         <span class="hljs-comment">// 下一个底面顶点</span><br>        triangles.Add(topStartIndex + i); <span class="hljs-comment">// 对应的顶部顶点</span><br><br>        triangles.Add(topStartIndex + i);         <span class="hljs-comment">// 顶部顶点</span><br>        triangles.Add(nextIndex);                 <span class="hljs-comment">// 下一个底面顶点</span><br>        triangles.Add(topStartIndex + nextIndex); <span class="hljs-comment">// 对应的顶部顶点</span><br>    &#125;<br><br>    <span class="hljs-comment">// 生成顶面的三角形</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; shadowPoints.Count - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        triangles.Add(topStartIndex);        <span class="hljs-comment">// 顶面的第一个点</span><br>        triangles.Add(topStartIndex + i);    <span class="hljs-comment">// 当前拔高后的点</span><br>        triangles.Add(topStartIndex + i + <span class="hljs-number">1</span>);<span class="hljs-comment">// 下一个拔高后的点</span><br>    &#125;<br><br>    <span class="hljs-comment">// 将顶点和三角形数据赋值给Mesh</span><br>    shadowMesh.vertices = vertices.ToArray();<br>    shadowMesh.triangles = triangles.ToArray();<br>    shadowMesh.RecalculateNormals(); <span class="hljs-comment">// 重新计算法线</span><br>    <br>    <span class="hljs-comment">// 添加碰撞体</span><br>    MeshCollider meshCollider = shadowEntity.GetComponent&lt;MeshCollider&gt;();<br>    <span class="hljs-keyword">if</span> (meshCollider == <span class="hljs-literal">null</span>)<br>    &#123;<br>        meshCollider = shadowEntity.AddComponent&lt;MeshCollider&gt;();<br>    &#125;<br>    meshCollider.sharedMesh = shadowMesh; <span class="hljs-comment">// 更新MeshCollider的网格</span><br>&#125;<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-start"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2025/04/14/%E8%89%BE%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E5%A2%83/">← Next 艾德里安的梦境Demo</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a><a onclick="BgmControl()"><svg id="bgm-control" viewBox="0 0 30 34" fill="#18d1ff" style="width: 24px; transition: transform .3s;margin-top: 4px"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="/audio/bgm.mp3" autoplay loop crossorigin="anonymous"> </audio></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">Muxi</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%89%E5%BD%B1%E6%A1%A5%E9%80%94-Demo"><span class="toc-number">1.</span> <span class="toc-text">光影桥途 Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.0.1.</span> <span class="toc-text">游戏概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%89%B9%E8%89%B2"><span class="toc-number">1.0.2.</span> <span class="toc-text">游戏特色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.3.</span> <span class="toc-text">技术实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E4%B8%BB%E8%A6%81%E8%B4%9F%E8%B4%A3%E9%83%A8%E5%88%86"><span class="toc-number">1.0.4.</span> <span class="toc-text">个人主要负责部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E6%88%AA%E5%9B%BE"><span class="toc-number">1.0.5.</span> <span class="toc-text">游戏截图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%9C%BA%E8%A7%86%E9%A2%91"><span class="toc-number">1.0.6.</span> <span class="toc-text">实机视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%82%B9%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="toc-number">1.0.7.</span> <span class="toc-text">一点小插曲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9AShadowVolumeGenerator"><span class="toc-number">1.0.8.</span> <span class="toc-text">核心机制具体实现：ShadowVolumeGenerator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">1. 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1%E8%AE%A1%E7%AE%97"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">2. 实时阴影计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%98%B4%E5%BD%B1%E6%8A%95%E5%BD%B1%E7%82%B9%E8%AE%A1%E7%AE%97"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">3. 阴影投影点计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">4. 凸包算法处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%98%B4%E5%BD%B1%E5%AE%9E%E4%BD%93%E7%BD%91%E6%A0%BC%E7%94%9F%E6%88%90"><span class="toc-number">1.0.8.5.</span> <span class="toc-text">5. 阴影实体网格生成</span></a></li></ol></li></ol></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>